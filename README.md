# rngpredict
Right now, it's not great for predicting numbers besides those generated by MSVC, but it's getting there. I'm serious about improving the code quality too, I *swear*. 


My Lua(JIT) version will beat this in every metric except maintainability, including accuracy, speed, and memory usage, and will do so long into the foreseeable future. I don't know how to optimize for Java particularly well, but if you do, please pitch in code.



The LuaJIT code is seen below: 


```lua
local bit32
local scaler = { }
local unpack = unpack

local floor = math.floor
do
  pcall (function()
    bit32 = require 'bit32'
  end)
  if bit then
    bit32 = bit
  end
  if not bit32 then
    print 'Using bit32 polyfill (much slower)'
    bit32 = { }
    function bit32.rshift (number, shifts)
      return floor (number % 2 ^ 32 / 2 ^ shifts)
    end
    function bit32.lshift (number, shifts)
      return (number * 2 ^ shifts) % 2 ^ 32
    end
  end
  unpack = unpack or table.unpack
end

do
  local ceil = math.ceil
  scaler.MAGIC = 5e5
  scaler.process = function(context)
    local values = { unpack (context) }
    local VALS_MAX = math.max (unpack (values) )
    local STEPPING = 0x7fff / VALS_MAX
    print ('Assuming max: ' .. VALS_MAX)
    for i = 1, #values do
      values[i] = ((values[i] - 1) * 0x7fff) / VALS_MAX
    end
    for i = 1, #values do
      local value = values[i]
      local possible = { }
      local MAGIC = scaler.MAGIC
      possible[MAGIC] = { }
      for step = 0, STEPPING do
        possible[MAGIC][ceil (value + step)] = true
        possible[step + 1] = ceil (value + step)
      end
      values[i] = possible
    end
    return values
  end
  scaler.scale = function(number, max, multiple)
    local out = (max * number / 0x7fff)
    return max == 1 and out or (floor (out) + (multiple and 1 or 0))
  end
end

local rshift = bit32.rshift
local function nextState(state)
  return rshift (((214013 * state + 2531011) % 2 ^ 31), 16)
end

local function shiftlessNextState(state)
  return (214013 * state + 2531011) % 2 ^ 31
end

local MAGIC = scaler.MAGIC
local function checkForState(possibleState, values, multiple)
  if multiple then
    for i = 2, #values do
      local map = values[i][MAGIC]
      if not map[nextState (possibleState)] then
        return
      else
        possibleState = shiftlessNextState (possibleState)
      end
    end
  else
    for i = 2, #values do
      if nextState (possibleState) == values[i] then
        possibleState = shiftlessNextState (possibleState)
      else
        return
      end
    end
  end
  return possibleState
end

local function currentState(values, multiple)
  if not multiple then
    local base = bit32.lshift (values[1], 16)
    for lowerBits = 0, 2 ^ 16 do
      local validState = checkForState (base + lowerBits, values, multiple)
      if validState then
        return validState
      end
    end
  else
    for _, potentialValue in ipairs (values[1]) do
      local base = bit32.lshift (potentialValue, 16)
      for lowerBits = 0, 2 ^ 16 do
        local validState = checkForState (base + lowerBits, values, multiple)
        if validState then
          return validState
        end
      end
    end
  end
  error 'Could not find a state'
end

local function nextValues(context, total, multiple)
  local state = currentState (context, multiple)
  local out = { }
  for i = 1, total do 
    state = shiftlessNextState(state)
    out[#out + 1] = rshift (state, 16)
  end
  return out
end

local function main(context)
  assert (#context >= 8, 'More inputs required for consistency.')
  local maximum = math.max (unpack (context))
  local multiple
  if maximum > 1 and maximum < 0x7fff / 2 then
    print 'Using math.random(n) mode.'
    context = scaler.process (context)
    multiple = true
  elseif maximum <= 1 then
    print 'Using math.random() mode.'
    for i = 1, #context do
      context[i] = floor (context[i] * 0x7fff + .5)
    end
    maximum = 1
  elseif maximum <= 0x7fff then
    print 'Using rand() mode.'
    maximum = 0x7fff
  end
  local output = nextValues (context, 10, multiple)
  for i, value in ipairs (output) do
    print ('Number #' .. i .. ': ' .. scaler.scale (value, maximum, multiple))
  end
end
```
